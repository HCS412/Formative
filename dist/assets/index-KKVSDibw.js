import{cn as $n,bK as Dn,cy as U,cz as pn,Y as M,ca as Gn,cA as zn,p as z,bJ as $,A as V,h as qn,r as Wn,B as Hn,j as D,k as an,l as Tn,m as Ln,L as jn,ab as Un,cg as Jn,n as un,o as Vn,t as H,u as Yn,aa as h,a as Xn,q as Zn,ck as nt,c as En,co as L,ae as P,b9 as tt,at as G,bC as et,cl as ot,ce as ct,bX as st,cm as rt,b8 as tn,ad as Cn,a2 as bn,ac as at,a4 as it,cj as ut,cB as dt,cC as W,ci as lt,cD as yt,ct as ft,cs as ht,cE as mn,U as x,b2 as gt,ax as wt,cF as In,a0 as pt,a8 as Ct,cG as bt,af as w,cH as mt,ag as y,y as g,ah as p,v as dn,cx as It,ai as Q,cI as qt,cJ as ln}from"./useChainId-D7YJGvzg.js";import{cM as As,cP as Ks,ch as Ps,cQ as Fs,cR as Rs,cS as Ns,cK as Os,cO as Qs,cL as Bs,cK as Ms,cL as xs,cN as $s,cq as Ds,cT as Gs}from"./useChainId-D7YJGvzg.js";import{w as Sn,i as Tt,c as Et,s as kn,d as St,v as kt,e as _t,f as vt,U as At,j as sn,k as Kt,g as Pt,l as Ft,m as Rt,n as Nt,o as Ot,q as Qt,t as Bt,x as J,y as Mt,z as xt,A as $t,B as Dt,C as Gt,D as rn,F as zt,G as Wt,H as Ht,I as Lt,J as jt,K as Ut}from"./useSwitchChain-Ddas0mjs.js";import{_ as Ws,$ as Hs,W as Ls,X as js,b as Us,Y as Js,Z as Vs,a0 as Ys,L as Xs,M as Zs,N as nr,O as tr,P as er,u as or,Q as cr,R as sr,S as rr,T as ar,V as ir}from"./useSwitchChain-Ddas0mjs.js";import{_ as Jt,r as O,o as Y}from"./index-DodDctfl.js";import{s as yn,w as fn,p as _n,g as vn}from"./waitForCallsStatus-BrCOB5r1.js";import{s as hn,a as An}from"./sendTransaction-vTUveoQV.js";import{w as Kn}from"./useWriteContract-DEJgYxTe.js";import{u as dr,a as lr,u as yr}from"./useWriteContract-DEJgYxTe.js";import{f as Vt}from"./fallback-ClpccPjf.js";import"./isAddressEqual-CLzLXNo_.js";import"./secp256k1-DEMtbeZA.js";const en=new Map;async function Yt(n){const{getSocket:t,keepAlive:e=!0,key:o="socket",reconnect:c=!0,url:s}=n,{interval:r=3e4}=typeof e=="object"?e:{},{attempts:a=5,delay:i=2e3}=typeof c=="object"?c:{},u=JSON.stringify({keepAlive:e,key:o,url:s,reconnect:c});let d=en.get(u);if(d)return d;let l=0;const{schedule:I}=$n({id:u,fn:async()=>{const S=new Map,q=new Map;let m,k,T,b=!1;function K(){if(c&&l<a){if(b)return;b=!0,l++,k?.close(),setTimeout(async()=>{await _().catch(console.error),b=!1},i)}else S.clear(),q.clear()}async function _(){const v=await t({onClose(){for(const E of S.values())E.onError?.(new U({url:s}));for(const E of q.values())E.onError?.(new U({url:s}));K()},onError(E){m=E;for(const A of S.values())A.onError?.(m);for(const A of q.values())A.onError?.(m);K()},onOpen(){m=void 0,l=0},onResponse(E){const A=E.method==="eth_subscription",R=A?E.params.subscription:E.id,N=A?q:S,F=N.get(R);F&&F.onResponse(E),A||N.delete(R)}});if(k=v,e&&(T&&clearInterval(T),T=setInterval(()=>k.ping?.(),r)),c&&q.size>0){const E=q.entries();for(const[A,{onResponse:R,body:N,onError:F}]of E)N&&(q.delete(A),d?.request({body:N,onResponse:R,onError:F}))}return v}return await _(),m=void 0,d={close(){T&&clearInterval(T),k.close(),en.delete(u)},get socket(){return k},request({body:v,onError:E,onResponse:A}){m&&E&&E(m);const R=v.id??Tt.take(),N=F=>{typeof F.id=="number"&&R!==F.id||(v.method==="eth_subscribe"&&typeof F.result=="string"&&q.set(F.result,{onResponse:N,onError:E,body:v}),v.method==="eth_unsubscribe"&&q.delete(v.params?.[0]),A(F))};S.set(R,{onResponse:N,onError:E});try{k.request({body:{jsonrpc:"2.0",id:R,...v}})}catch(F){E?.(F)}},requestAsync({body:v,timeout:E=1e4}){return Sn(()=>new Promise((A,R)=>this.request({body:v,onError:R,onResponse:A})),{errorInstance:new Dn({body:v,url:s}),timeout:E})},requests:S,subscriptions:q,url:s},en.set(u,d),[d]}}),[f,[C]]=await I();return C}async function j(n,t={}){const{keepAlive:e,reconnect:o}=t;return Yt({async getSocket({onClose:c,onError:s,onOpen:r,onResponse:a}){const i=await Jt(()=>import("./native-Bz5QQgeN.js").then(f=>f.n),[]).then(f=>f.WebSocket),u=new i(n);function d(){u.removeEventListener("close",d),u.removeEventListener("message",l),u.removeEventListener("error",s),u.removeEventListener("open",r),c()}function l({data:f}){if(!(typeof f=="string"&&f.trim().length===0))try{const C=JSON.parse(f);a(C)}catch(C){s(C)}}u.addEventListener("close",d),u.addEventListener("message",l),u.addEventListener("error",s),u.addEventListener("open",r),u.readyState===i.CONNECTING&&await new Promise((f,C)=>{u&&(u.onopen=f,u.onerror=C)});const{close:I}=u;return Object.assign(u,{close(){I.bind(u)(),d()},ping(){try{if(u.readyState===u.CLOSED||u.readyState===u.CLOSING)throw new pn({url:u.url,cause:new U({url:u.url})});const f={jsonrpc:"2.0",id:null,method:"net_version",params:[]};u.send(JSON.stringify(f))}catch(f){s(f)}},request({body:f}){if(u.readyState===u.CLOSED||u.readyState===u.CLOSING)throw new pn({body:f,url:u.url,cause:new U({url:u.url})});return u.send(JSON.stringify(f))}})},keepAlive:e,reconnect:o,url:n})}function Xt(n,{body:t,onError:e,onResponse:o}){return n.request({body:t,onError:e,onResponse:o}),n}async function Zt(n,{body:t,timeout:e=1e4}){return n.requestAsync({body:t,timeout:e})}async function ne(n){const t=await j(n);return Object.assign(t.socket,{requests:t.requests,subscriptions:t.subscriptions})}const on={http(n,t){return Et(n).request(t)},webSocket:Xt,webSocketAsync:Zt};async function te(n,{chain:t}){const{id:e,name:o,nativeCurrency:c,rpcUrls:s,blockExplorers:r}=t;await n.request({method:"wallet_addEthereumChain",params:[{chainId:M(e),chainName:o,nativeCurrency:c,rpcUrls:s.default.http,blockExplorerUrls:r?Object.values(r).map(({url:a})=>a):void 0}]},{dedupe:!0,retryCount:0})}function Pn(n,t){const{abi:e,args:o,bytecode:c,...s}=t,r=Gn({abi:e,args:o,bytecode:c});return hn(n,{...s,...s.authorizationList?{to:null}:{},data:r})}async function ee(n){return n.account?.type==="local"?[n.account.address]:(await n.request({method:"eth_accounts"},{dedupe:!0})).map(e=>zn(e))}async function Fn(n,t={}){const{account:e=n.account,chainId:o}=t,c=e?z(e):void 0,s=o?[c?.address,[M(o)]]:[c?.address],r=await n.request({method:"wallet_getCapabilities",params:s}),a={};for(const[i,u]of Object.entries(r)){a[Number(i)]={};for(let[d,l]of Object.entries(u))d==="addSubAccount"&&(d="unstable_addSubAccount"),a[Number(i)][d]=l}return typeof o=="number"?a[o]:a}async function oe(n){return await n.request({method:"wallet_getPermissions"},{dedupe:!0})}async function ce(n){return(await n.request({method:"eth_requestAccounts"},{dedupe:!0,retryCount:0})).map(e=>$(e))}async function se(n,t){return n.request({method:"wallet_requestPermissions",params:[t]},{retryCount:0})}async function Rn(n,t){const{chain:e=n.chain}=t,o=t.timeout??Math.max((e?.blockTime??0)*3,5e3),c=await yn(n,t);return await fn(n,{...t,id:c.id,timeout:o})}const cn=new jn(128);async function gn(n,t){const{account:e=n.account,chain:o=n.chain,accessList:c,authorizationList:s,blobs:r,data:a,gas:i,gasPrice:u,maxFeePerBlobGas:d,maxFeePerGas:l,maxPriorityFeePerGas:I,nonce:f,pollingInterval:C,throwOnReceiptRevert:S,type:q,value:m,...k}=t,T=t.timeout??Math.max((o?.blockTime??0)*3,5e3);if(typeof e>"u")throw new V({docsPath:"/docs/actions/wallet/sendTransactionSync"});const b=e?z(e):null;try{qn(t);const K=await(async()=>{if(t.to)return t.to;if(t.to!==null&&s&&s.length>0)return await Wn({authorization:s[0]}).catch(()=>{throw new Hn("`to` is required. Could not infer from `authorizationList`.")})})();if(b?.type==="json-rpc"||b===null){let _;o!==null&&(_=await D(n,an,"getChainId")({}),An({currentChainId:_,chain:o}));const v=n.chain?.formatters?.transactionRequest?.format,A=(v||Tn)({...Ln(k,{format:v}),accessList:c,account:b,authorizationList:s,blobs:r,chainId:_,data:a,gas:i,gasPrice:u,maxFeePerBlobGas:d,maxFeePerGas:l,maxPriorityFeePerGas:I,nonce:f,to:K,type:q,value:m},"sendTransaction"),R=cn.get(n.uid),N=R?"wallet_sendTransaction":"eth_sendTransaction",F=await(async()=>{try{return await n.request({method:N,params:[A]},{retryCount:0})}catch(wn){if(R===!1)throw wn;const B=wn;if(B.name==="InvalidInputRpcError"||B.name==="InvalidParamsRpcError"||B.name==="MethodNotFoundRpcError"||B.name==="MethodNotSupportedRpcError")return await n.request({method:"wallet_sendTransaction",params:[A]},{retryCount:0}).then(Z=>(cn.set(n.uid,!0),Z)).catch(Z=>{const nn=Z;throw nn.name==="MethodNotFoundRpcError"||nn.name==="MethodNotSupportedRpcError"?(cn.set(n.uid,!1),B):nn});throw B}})(),X=await D(n,Un,"waitForTransactionReceipt")({checkReplacement:!1,hash:F,pollingInterval:C,timeout:T});if(S&&X.status==="reverted")throw new Jn({receipt:X});return X}if(b?.type==="local"){const _=await D(n,un,"prepareTransactionRequest")({account:b,accessList:c,authorizationList:s,blobs:r,chain:o,data:a,gas:i,gasPrice:u,maxFeePerBlobGas:d,maxFeePerGas:l,maxPriorityFeePerGas:I,nonce:f,nonceManager:b.nonceManager,parameters:[...Vn,"sidecars"],type:q,value:m,...k,to:K}),v=o?.serializers?.transaction,E=await b.signTransaction(_,{serializer:v});return await D(n,kn,"sendRawTransactionSync")({serializedTransaction:E,throwOnReceiptRevert:S})}throw b?.type==="smart"?new H({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"}):new H({docsPath:"/docs/actions/wallet/sendTransactionSync",type:b?.type})}catch(K){throw K instanceof H?K:Yn(K,{...t,account:b,chain:t.chain||void 0})}}async function Nn(n,t){const{id:e}=t;await n.request({method:"wallet_showCallsStatus",params:[e]})}async function re(n,t){const{account:e=n.account}=t;if(!e)throw new V({docsPath:"/docs/eip7702/signAuthorization"});const o=z(e);if(!o.signAuthorization)throw new H({docsPath:"/docs/eip7702/signAuthorization",metaMessages:["The `signAuthorization` Action does not support JSON-RPC Accounts."],type:o.type});const c=await _n(n,t);return o.signAuthorization(c)}async function ae(n,t){const{account:e=n.account,chain:o=n.chain,...c}=t;if(!e)throw new V({docsPath:"/docs/actions/wallet/signTransaction"});const s=z(e);qn({account:s,...t});const r=await D(n,an,"getChainId")({});o!==null&&An({currentChainId:r,chain:o});const i=(o?.formatters||n.chain?.formatters)?.transactionRequest?.format||Tn;return s.signTransaction?s.signTransaction({...c,chainId:r},{serializer:n.chain?.serializers?.transaction}):await n.request({method:"eth_signTransaction",params:[{...i({...c,account:s},"signTransaction"),chainId:M(r),from:s.address}]},{retryCount:0})}async function On(n,t){const{account:e=n.account,domain:o,message:c,primaryType:s}=t;if(!e)throw new V({docsPath:"/docs/actions/wallet/signTypedData"});const r=z(e),a={EIP712Domain:St({domain:o}),...t.types};if(kt({domain:o,message:c,primaryType:s,types:a}),r.signTypedData)return r.signTypedData({domain:o,message:c,primaryType:s,types:a});const i=_t({domain:o,message:c,primaryType:s,types:a});return n.request({method:"eth_signTypedData_v4",params:[r.address,i]},{retryCount:0})}async function ie(n,{id:t}){await n.request({method:"wallet_switchEthereumChain",params:[{chainId:M(t)}]},{retryCount:0})}async function Qn(n,t){return await n.request({method:"wallet_watchAsset",params:t},{retryCount:0})}async function ue(n,t){return Kn.internal(n,gn,"sendTransactionSync",t)}async function de(n,t){const{chainId:e,...o}=t,c=n.getClient({chainId:e});return h(c,Xn,"call")(o)}function le(n){return{addChain:t=>te(n,t),deployContract:t=>Pn(n,t),fillTransaction:t=>nt(n,t),getAddresses:()=>ee(n),getCallsStatus:t=>vn(n,t),getCapabilities:t=>Fn(n,t),getChainId:()=>an(n),getPermissions:()=>oe(n),prepareAuthorization:t=>_n(n,t),prepareTransactionRequest:t=>un(n,t),requestAddresses:()=>ce(n),requestPermissions:t=>se(n,t),sendCalls:t=>yn(n,t),sendCallsSync:t=>Rn(n,t),sendRawTransaction:t=>Zn(n,t),sendRawTransactionSync:t=>kn(n,t),sendTransaction:t=>hn(n,t),sendTransactionSync:t=>gn(n,t),showCallsStatus:t=>Nn(n,t),signAuthorization:t=>re(n,t),signMessage:t=>vt(n,t),signTransaction:t=>ae(n,t),signTypedData:t=>On(n,t),switchChain:t=>ie(n,t),waitForCallsStatus:t=>fn(n,t),watchAsset:t=>Qn(n,t),writeContract:t=>Kn(n,t),writeContractSync:t=>ue(n,t)}}function Pc(n,t={}){const{keepAlive:e,key:o="webSocket",methods:c,name:s="WebSocket JSON-RPC",reconnect:r,retryDelay:a}=t;return({chain:i,retryCount:u,timeout:d})=>{const l=t.retryCount??u,I=d??t.timeout??1e4,f=n||i?.rpcUrls.default.webSocket?.[0],C={keepAlive:e,reconnect:r};if(!f)throw new At;return En({key:o,methods:c,name:s,async request({method:S,params:q}){const m={method:S,params:q},k=await j(f,C),{error:T,result:b}=await k.requestAsync({body:m,timeout:I});if(T)throw new L({body:m,error:T,url:f});return b},retryCount:l,retryDelay:a,timeout:I,type:"webSocket"},{getSocket(){return ne(f)},getRpcClient(){return j(f,C)},async subscribe({params:S,onData:q,onError:m}){const k=await j(f,C),{result:T}=await new Promise((b,K)=>k.request({body:{method:"eth_subscribe",params:S},onError(_){K(_),m?.(_)},onResponse(_){if(_.error){K(_.error),m?.(_.error);return}if(typeof _.id=="number"){b(_);return}_.method==="eth_subscription"&&q(_.params)}}));return{subscriptionId:T,async unsubscribe(){return new Promise(b=>k.request({body:{method:"eth_unsubscribe",params:[T]},onResponse:b}))}}}})}}async function ye(n,t){const{account:e,chainId:o,connector:c,...s}=t;let r;return typeof e=="object"&&e?.type==="local"?r=n.getClient({chainId:o}):r=await P(n,{account:e??void 0,assertChainId:!1,chainId:o,connector:c}),await h(r,Pn,"deployContract")({...s,...e?{account:e}:{},chain:o?{id:o}:null})}async function fe(n,t={}){const{chainId:e,formatUnits:o="gwei",...c}=t,s=n.getClient({chainId:e}),r=h(s,tt,"estimateFeesPerGas"),{gasPrice:a,maxFeePerGas:i,maxPriorityFeePerGas:u}=await r({...c,chain:s.chain}),d=sn(o);return{formatted:{gasPrice:a?G(a,d):void 0,maxFeePerGas:i?G(i,d):void 0,maxPriorityFeePerGas:u?G(u,d):void 0},gasPrice:a,maxFeePerGas:i,maxPriorityFeePerGas:u}}async function he(n,t){const{chainId:e,connector:o,...c}=t;let s;t.account?s=t.account:s=(await P(n,{account:t.account,assertChainId:!1,chainId:e,connector:o})).account;const r=n.getClient({chainId:e});return h(r,et,"estimateGas")({...c,account:s})}async function ge(n,t={}){const{chainId:e}=t,o=n.getClient({chainId:e});return h(o,ot,"estimateMaxPriorityFeePerGas")({chain:o.chain})}async function we(n,t={}){const{chainId:e,...o}=t,c=n.getClient({chainId:e});return{...await h(c,ct,"getBlock")(o),chainId:c.chain.id}}function pe(n,t={}){const{chainId:e,...o}=t,c=n.getClient({chainId:e});return h(c,st,"getBlockNumber")(o)}function Ce(n,t={}){const{chainId:e,...o}=t,c=n.getClient({chainId:e});return h(c,Kt,"getBlockTransactionCount")(o)}async function be(n,t){const{chainId:e,...o}=t,c=n.getClient({chainId:e});return h(c,Pt,"getBytecode")(o)}async function me(n,t){const{connector:e,id:o}=t,c=await P(n,{connector:e});return h(c,vn,"getCallsStatus")({id:o})}async function Ie(n,t={}){const{account:e,chainId:o,connector:c}=t,s=await P(n,{account:e,connector:c});return Fn(s,{account:e,chainId:o})}function qe(n,t){const{chainId:e,...o}=t,c=n.getClient({chainId:e});return h(c,Ft,"getEnsAddress")(o)}function Te(n,t){const{chainId:e,...o}=t,c=n.getClient({chainId:e});return h(c,Rt,"getEnsResolver")(o)}function Ee(n,t){const{chainId:e,...o}=t,c=n.getClient({chainId:e});return h(c,Nt,"getEnsText")(o)}function Se(n,t){const{chainId:e,...o}=t,c=n.getClient({chainId:e});return h(c,Ot,"getFeeHistory")(o)}function ke(n,t={}){const{chainId:e}=t,o=n.getClient({chainId:e});return h(o,rt,"getGasPrice")({})}async function _e(n,t){const{chainId:e,...o}=t,c=n.getClient({chainId:e});return h(c,Qt,"getProof")(o)}async function ve(n,t){const{chainId:e,...o}=t,c=n.getClient({chainId:e});return h(c,Bt,"getStorageAt")(o)}async function Ae(n,t){const{address:e,chainId:o,formatUnits:c=18}=t;function s(r){return[{type:"function",name:"decimals",stateMutability:"view",inputs:[],outputs:[{type:"uint8"}]},{type:"function",name:"name",stateMutability:"view",inputs:[],outputs:[{type:r}]},{type:"function",name:"symbol",stateMutability:"view",inputs:[],outputs:[{type:r}]},{type:"function",name:"totalSupply",stateMutability:"view",inputs:[],outputs:[{type:"uint256"}]}]}try{const r=s("string"),a={address:e,abi:r,chainId:o},[i,u,d,l]=await J(n,{allowFailure:!0,contracts:[{...a,functionName:"decimals"},{...a,functionName:"name"},{...a,functionName:"symbol"},{...a,functionName:"totalSupply"}]});if(u.error instanceof tn)throw u.error;if(d.error instanceof tn)throw d.error;if(i.error)throw i.error;if(l.error)throw l.error;return{address:e,decimals:i.result,name:u.result,symbol:d.result,totalSupply:{formatted:G(l.result,sn(c)),value:l.result}}}catch(r){if(r instanceof tn){const a=s("bytes32"),i={address:e,abi:a,chainId:o},[u,d,l,I]=await J(n,{allowFailure:!1,contracts:[{...i,functionName:"decimals"},{...i,functionName:"name"},{...i,functionName:"symbol"},{...i,functionName:"totalSupply"}]});return{address:e,decimals:u,name:Cn(bn(d,{dir:"right"})),symbol:Cn(bn(l,{dir:"right"})),totalSupply:{formatted:G(I,sn(c)),value:I}}}throw r}}function Ke(n,t){const{chainId:e,...o}=t,c=n.getClient({chainId:e});return h(c,at,"getTransaction")(o)}function Pe(n,t){const{chainId:e,...o}=t,c=n.getClient({chainId:e});return h(c,Mt,"getTransactionConfirmations")(o)}async function Fe(n,t){const{address:e,blockNumber:o,blockTag:c,chainId:s}=t,r=n.getClient({chainId:s});return h(r,it,"getTransactionCount")(o?{address:e,blockNumber:o}:{address:e,blockTag:c})}async function Re(n,t){const{chainId:e,...o}=t,c=n.getClient({chainId:e});return h(c,ut,"getTransactionReceipt")(o)}async function Ne(n,t={}){return(await P(n,t)).extend(le)}async function Oe(n,t){const{account:e,chainId:o,...c}=t,s=e??dt(n).address,r=n.getClient({chainId:o});return h(r,un,"prepareTransactionRequest")({...c,...s?{account:s}:{}})}async function Qe(n,t){const{account:e,chainId:o,connector:c,calls:s,...r}=t,a=await P(n,{account:e,assertChainId:!1,chainId:o,connector:c});return h(a,yn,"sendCalls")({...r,...typeof e<"u"?{account:e}:{},calls:s,chain:o?{id:o}:void 0})}async function Be(n,t){const{account:e,chainId:o,connector:c,calls:s,...r}=t,a=await P(n,{account:e,assertChainId:!1,chainId:o,connector:c});return h(a,Rn,"sendCallsSync")({...r,...typeof e<"u"?{account:e}:{},calls:s,chain:o?{id:o}:void 0})}async function Me(n,t){const{account:e,chainId:o,connector:c,...s}=t;let r;return typeof e=="object"&&e?.type==="local"?r=n.getClient({chainId:o}):r=await P(n,{account:e??void 0,assertChainId:!1,chainId:o,connector:c}),await h(r,hn,"sendTransaction")({...s,...e?{account:e}:{},chain:o?{id:o}:null,gas:s.gas??void 0})}async function xe(n,t){const{account:e,chainId:o,connector:c,...s}=t;let r;return typeof e=="object"&&e?.type==="local"?r=n.getClient({chainId:o}):r=await P(n,{account:e??void 0,assertChainId:!1,chainId:o,connector:c}),await h(r,gn,"sendTransactionSync")({...s,...e?{account:e}:{},chain:o?{id:o}:null,gas:s.gas??void 0})}async function $e(n,t){const{connector:e,id:o}=t,c=await P(n,{connector:e});return Nn(c,{id:o})}async function De(n,t){const{account:e,connector:o,...c}=t;let s;return typeof e=="object"&&e.type==="local"?s=n.getClient():s=await P(n,{account:e,connector:o}),h(s,On,"signTypedData")({...c,...e?{account:e}:{}})}async function Ge(n,t){const{abi:e,chainId:o,connector:c,...s}=t;let r;t.account?r=t.account:r=(await P(n,{assertChainId:!1,chainId:o,connector:c})).account;const a=n.getClient({chainId:o}),i=h(a,xt,"simulateContract"),{result:u,request:d}=await i({...s,abi:e,account:r});return{chainId:a.chain.id,result:u,request:{...d,chainId:o}}}async function ze(n,t){const{connector:e}=t,o=n.state.connections.get(e.uid);if(!o)throw new W;return await n.storage?.setItem("recentConnectorId",e.id),n.setState(c=>({...c,current:e.uid})),{accounts:o.accounts,chainId:o.chainId}}async function We(n,t){const{chainId:e,...o}=t,c=n.getClient({chainId:e});return h(c,$t,"verifyMessage")(o)}async function He(n,t){const{chainId:e,...o}=t,c=n.getClient({chainId:e});return h(c,Dt,"verifyTypedData")(o)}async function Le(n,t){const{connector:e}=t,o=await P(n,{connector:e});return fn(o,t)}async function je(n,t){const{connector:e,...o}=t,c=await P(n,{connector:e});return h(c,Qn,"watchAsset")(o)}function Ue(n,t){const{syncConnectedChain:e=n._internal.syncConnectedChain,...o}=t;let c;const s=i=>{c&&c();const u=n.getClient({chainId:i});return c=h(u,lt,"watchBlockNumber")(o),c},r=s(t.chainId);let a;return e&&!t.chainId&&(a=n.subscribe(({chainId:i})=>i,async i=>s(i))),()=>{r?.(),a?.()}}function Je(n,t){const{syncConnectedChain:e=n._internal.syncConnectedChain,...o}=t;let c;const s=i=>{c&&c();const u=n.getClient({chainId:i});return c=h(u,Gt,"watchBlocks")(o),c},r=s(t.chainId);let a;return e&&!t.chainId&&(a=n.subscribe(({chainId:i})=>i,async i=>s(i))),()=>{r?.(),a?.()}}function Ve(n,t){const{onChange:e}=t;return n.subscribe(()=>rn(n),e,{equalityFn(o,c){return o?.uid===c?.uid}})}function Ye(n,t){const{syncConnectedChain:e=n._internal.syncConnectedChain,...o}=t;let c;const s=i=>{c&&c();const u=n.getClient({chainId:i});return c=h(u,zt,"watchContractEvent")(o),c},r=s(t.chainId);let a;return e&&!t.chainId&&(a=n.subscribe(({chainId:i})=>i,async i=>s(i))),()=>{r?.(),a?.()}}function Xe(n,t){const{syncConnectedChain:e=n._internal.syncConnectedChain,...o}=t;let c;const s=i=>{c&&c();const u=n.getClient({chainId:i});return c=h(u,Wt,"watchPendingTransactions")(o),c},r=s(t.chainId);let a;return e&&!t.chainId&&(a=n.subscribe(({chainId:i})=>i,async i=>s(i))),()=>{r?.(),a?.()}}Bn.type="mock";function Bn(n){const t=new Map,e=n.features??{defaultConnected:!1};let o=e.defaultConnected,c;return Ht(s=>({id:"mock",name:"Mock Connector",type:Bn.type,async setup(){c=s.chains[0].id},async connect({chainId:r,withCapabilities:a}={}){if(e.connectError)throw typeof e.connectError=="boolean"?new x(new Error("Failed to connect.")):e.connectError;const u=await(await this.getProvider()).request({method:"eth_requestAccounts"});let d=await this.getChainId();return r&&d!==r&&(d=(await this.switchChain({chainId:r})).id),o=!0,{accounts:a?u.map(l=>({address:$(l),capabilities:{foo:{bar:l}}})):u.map(l=>$(l)),chainId:d}},async disconnect(){o=!1},async getAccounts(){if(!o)throw new W;return(await(await this.getProvider()).request({method:"eth_accounts"})).map(i=>$(i))},async getChainId(){const a=await(await this.getProvider()).request({method:"eth_chainId"});return mn(a,"number")},async isAuthorized(){return!e.reconnect||!o?!1:!!(await this.getAccounts()).length},async switchChain({chainId:r}){const a=await this.getProvider(),i=s.chains.find(u=>u.id===r);if(!i)throw new ft(new ht);return await a.request({method:"wallet_switchEthereumChain",params:[{chainId:M(r)}]}),i},onAccountsChanged(r){r.length===0?this.onDisconnect():s.emitter.emit("change",{accounts:r.map(a=>$(a))})},onChainChanged(r){const a=Number(r);s.emitter.emit("change",{chainId:a})},async onDisconnect(r){s.emitter.emit("disconnect"),o=!1},async getProvider({chainId:r}={}){const i=(s.chains.find(d=>d.id===r)??s.chains[0]).rpcUrls.default.http[0];return yt({request:async({method:d,params:l})=>{if(d==="eth_chainId")return M(c);if(d==="eth_requestAccounts")return n.accounts;if(d==="eth_signTypedData_v4"&&e.signTypedDataError)throw typeof e.signTypedDataError=="boolean"?new x(new Error("Failed to sign typed data.")):e.signTypedDataError;if(d==="wallet_switchEthereumChain"){if(e.switchChainError)throw typeof e.switchChainError=="boolean"?new x(new Error("Failed to switch chain.")):e.switchChainError;c=mn(l[0].chainId,"number"),this.onChainChanged(c.toString());return}if(d==="wallet_watchAsset"){if(e.watchAssetError)throw typeof e.watchAssetError=="boolean"?new x(new Error("Failed to switch chain.")):e.watchAssetError;return o}if(d==="wallet_getCapabilities")return{"0x2105":{paymasterService:{supported:l[0]==="0x95132632579b073D12a6673e18Ab05777a6B86f8"},sessionKeys:{supported:!0}},"0x14A34":{paymasterService:{supported:l[0]==="0x95132632579b073D12a6673e18Ab05777a6B86f8"}}};if(d==="wallet_sendCalls"){const S=[],q=l[0].calls,m=l[0].from;for(const T of q){const{result:b,error:K}=await on.http(i,{body:{method:"eth_sendTransaction",params:[{...T,...typeof m<"u"?{from:m}:{}}]}});if(K)throw new L({body:{method:d,params:l},error:K,url:i});S.push(b)}const k=gt(wt(JSON.stringify(q)));return t.set(k,S),{id:k}}if(d==="wallet_getCallsStatus"){const S=t.get(l[0]);if(!S)return{atomic:!1,chainId:"0x1",id:l[0],status:100,receipts:[],version:"2.0.0"};const m=(await Promise.all(S.map(async k=>{const{result:T,error:b}=await on.http(i,{body:{method:"eth_getTransactionReceipt",params:[k],id:0}});if(b)throw new L({body:{method:d,params:l},error:b,url:i});return T?{blockHash:T.blockHash,blockNumber:T.blockNumber,gasUsed:T.gasUsed,logs:T.logs,status:T.status,transactionHash:T.transactionHash}:null}))).filter(k=>k!==null);return m.length===0?{atomic:!1,chainId:"0x1",id:l[0],status:100,receipts:[],version:"2.0.0"}:{atomic:!1,chainId:"0x1",id:l[0],status:200,receipts:m,version:"2.0.0"}}if(d==="wallet_showCallsStatus")return;if(d==="personal_sign"){if(e.signMessageError)throw typeof e.signMessageError=="boolean"?new x(new Error("Failed to sign message.")):e.signMessageError;d="eth_sign",l=[l[1],l[0]]}const I={method:d,params:l},{error:f,result:C}=await on.http(i,{body:I});if(f)throw new L({body:I,error:f,url:i});return C}})({retryCount:0})}}))}function Fc(n,t={}){const{type:e}=n,{key:o="connector",name:c="Connector",retryDelay:s}=t;return r=>{const{chain:a,connectors:i}=r,u=t.retryCount??r.retryCount;return En({key:o,name:c,request:async({method:l,params:I})=>{const f=i?.getState().find(m=>m.type===e);if(!f)throw new In(new Error(`Could not find connector of type "${e}" in \`connectors\` passed to \`createConfig\`.`));const C=await f.getProvider({chainId:a?.id});if(!C)throw new In(new Error("Provider is disconnected."));const S=pt(await Ct(()=>Sn(()=>C.request({method:"eth_chainId"}),{timeout:100})));if(a&&S!==a.id)throw new bt(new Error(`The current chain of the connector (id: ${S}) does not match the target chain for the request (id: ${a.id} â€“ ${a.name}).`));const q={method:l,params:I};return C.request(q)},retryCount:u,retryDelay:s,type:"connector"})}}function Rc(n,t){return Vt(n,t)}const Nc={getItem(n){return typeof window>"u"?null:Mn(document.cookie,n)??null},setItem(n,t){typeof window>"u"||(document.cookie=`${n}=${t};path=/;samesite=Lax`)},removeItem(n){typeof window>"u"||(document.cookie=`${n}=;max-age=-1;path=/`)}};function Oc(n,t){if(!t)return;const e=`${n.storage?.key}.store`,o=Mn(t,e);if(o)return Lt(o).state}function Mn(n,t){const e=n.split("; ").find(o=>o.startsWith(`${t}=`));if(e)return e.substring(t.length+1)}function Qc(n){if(typeof n=="string")return Number.parseInt(n,n.trim().substring(0,2)==="0x"?16:10);if(typeof n=="bigint")return Number(n);if(typeof n=="number")return n;throw new Error(`Cannot normalize chainId "${n}" of type "${typeof n}"`)}function Ze(n,t={}){return{async queryFn({queryKey:e}){const{scopeKey:o,...c}=e[1];return await de(n,{...c})??null},queryKey:no(t)}}function no(n){return["call",w(n)]}function to(n){return{mutationFn(t){return ye(n,t)},mutationKey:["deployContract"]}}function eo(n,t={}){return{async queryFn({queryKey:e}){const{scopeKey:o,...c}=e[1];return fe(n,c)},queryKey:oo(t)}}function oo(n={}){return["estimateFeesPerGas",w(n)]}function co(n,t={}){return{async queryFn({queryKey:e}){const{connector:o}=t,{account:c,scopeKey:s,...r}=e[1];if(!c&&!o)throw new Error("account or connector is required");return he(n,{account:c,connector:o,...r})},queryKey:so(t)}}function so(n={}){const{connector:t,...e}=n;return["estimateGas",w(e)]}function ro(n,t={}){return{async queryFn({queryKey:e}){const{scopeKey:o,...c}=e[1];return ge(n,c)},queryKey:ao(t)}}function ao(n={}){return["estimateMaxPriorityFeePerGas",w(n)]}function io(n,t={}){return{async queryFn({queryKey:e}){const{scopeKey:o,...c}=e[1];return await we(n,c)??null},queryKey:uo(t)}}function uo(n={}){return["block",w(n)]}function lo(n,t={}){return{gcTime:0,async queryFn({queryKey:e}){const{scopeKey:o,...c}=e[1];return await pe(n,c)??null},queryKey:yo(t)}}function yo(n={}){return["blockNumber",w(n)]}function fo(n,t={}){return{async queryFn({queryKey:e}){const{scopeKey:o,...c}=e[1];return await Ce(n,c)??null},queryKey:ho(t)}}function ho(n={}){return["blockTransactionCount",w(n)]}function go(n,t={}){return{async queryFn({queryKey:e}){const{address:o,scopeKey:c,...s}=e[1];if(!o)throw new Error("address is required");return await be(n,{...s,address:o})??null},queryKey:wo(t)}}function wo(n){return["getBytecode",w(n)]}function po(n,t){return{async queryFn({queryKey:e}){const{scopeKey:o,...c}=e[1];return await me(n,c)},queryKey:Co(t),retry(e,o){return o instanceof W?!1:e<3}}}function Co(n){return["callsStatus",w(n)]}function bo(n,t={}){return{async queryFn({queryKey:e}){const{scopeKey:o,...c}=e[1];return await Ie(n,c)},queryKey:mo(t),retry(e,o){return o instanceof W?!1:e<3}}}function mo(n={}){return["capabilities",w(n)]}function Io(n,t={}){return{gcTime:0,async queryFn({queryKey:e}){const{connector:o}=t,{connectorUid:c,scopeKey:s,...r}=e[1];return P(n,{...r,connector:o})},queryKey:qo(t)}}function qo(n={}){const{connector:t,...e}=n;return["connectorClient",{...w(e),connectorUid:t?.uid}]}function To(n,t={}){return{async queryFn({queryKey:e}){const{name:o,scopeKey:c,...s}=e[1];if(!o)throw new Error("name is required");return qe(n,{...s,name:o})},queryKey:Eo(t)}}function Eo(n={}){return["ensAddress",w(n)]}function So(n,t={}){return{async queryFn({queryKey:e}){const{name:o,scopeKey:c,...s}=e[1];if(!o)throw new Error("name is required");return Te(n,{...s,name:o})},queryKey:ko(t)}}function ko(n={}){return["ensResolver",w(n)]}function _o(n,t={}){return{async queryFn({queryKey:e}){const{key:o,name:c,scopeKey:s,...r}=e[1];if(!o||!c)throw new Error("key and name are required");return Ee(n,{...r,key:o,name:c})},queryKey:vo(t)}}function vo(n={}){return["ensText",w(n)]}function Ao(n,t={}){return{async queryFn({queryKey:e}){const{blockCount:o,rewardPercentiles:c,scopeKey:s,...r}=e[1];if(!o)throw new Error("blockCount is required");if(!c)throw new Error("rewardPercentiles is required");return await Se(n,{...r,blockCount:o,rewardPercentiles:c})??null},queryKey:Ko(t)}}function Ko(n={}){return["feeHistory",w(n)]}function Po(n,t={}){return{async queryFn({queryKey:e}){const{scopeKey:o,...c}=e[1];return await ke(n,c)??null},queryKey:Fo(t)}}function Fo(n={}){return["gasPrice",w(n)]}function Ro(n,t={}){return{async queryFn({queryKey:e}){const{address:o,scopeKey:c,storageKeys:s,...r}=e[1];if(!o||!s)throw new Error("address and storageKeys are required");return _e(n,{...r,address:o,storageKeys:s})},queryKey:No(t)}}function No(n){return["getProof",w(n)]}function Oo(n,t={}){return{queryFn({queryKey:e}){const{address:o,slot:c,scopeKey:s,...r}=e[1];if(!o||!c)throw new Error("address and slot are required");return ve(n,{...r,address:o,slot:c})},queryKey:Qo(t)}}function Qo(n){return["getStorageAt",w(n)]}function Bo(n,t={}){return{async queryFn({queryKey:e}){const{address:o,scopeKey:c,...s}=e[1];if(!o)throw new Error("address is required");return Ae(n,{...s,address:o})},queryKey:Mo(t)}}function Mo(n={}){return["token",w(n)]}function xo(n,t={}){return{async queryFn({queryKey:e}){const{blockHash:o,blockNumber:c,blockTag:s,hash:r,index:a}=e[1];if(!o&&!c&&!s&&!r)throw new Error("blockHash, blockNumber, blockTag, or hash is required");if(!r&&!a)throw new Error("index is required for blockHash, blockNumber, or blockTag");const{scopeKey:i,...u}=e[1];return Ke(n,u)},queryKey:$o(t)}}function $o(n={}){return["transaction",w(n)]}function Do(n,t={}){return{async queryFn({queryKey:e}){const{hash:o,transactionReceipt:c,scopeKey:s,...r}=e[1];if(!o&&!c)throw new Error("hash or transactionReceipt is required");return await Pe(n,{hash:o,transactionReceipt:c,...r})??null},queryKey:Go(t)}}function Go(n={}){return["transactionConfirmations",w(n)]}function zo(n,t={}){return{async queryFn({queryKey:e}){const{address:o,scopeKey:c,...s}=e[1];if(!o)throw new Error("address is required");return await Fe(n,{...s,address:o})??null},queryKey:Wo(t)}}function Wo(n={}){return["transactionCount",w(n)]}function Ho(n,t={}){return{queryFn({queryKey:e}){const{hash:o,scopeKey:c,...s}=e[1];if(!o)throw new Error("hash is required");return Re(n,{...s,hash:o})},queryKey:Lo(t)}}function Lo(n){return["getTransactionReceipt",w(n)]}function jo(n,t={}){return{gcTime:0,async queryFn({queryKey:e}){const{connector:o}=t,{connectorUid:c,scopeKey:s,...r}=e[1];return Ne(n,{...r,connector:o})},queryKey:Uo(t)}}function Uo(n={}){const{connector:t,...e}=n;return["walletClient",{...w(e),connectorUid:t?.uid}]}function Jo(n,t){return{...t.query,async queryFn({pageParam:e,queryKey:o}){const{contracts:c}=t,{cacheKey:s,scopeKey:r,...a}=o[1];return await J(n,{...a,contracts:c(e)})},queryKey:Vo(t)}}function Vo(n){const{contracts:t,query:e,...o}=n;return["infiniteReadContracts",w(o)]}function Yo(n,t={}){return{queryFn({queryKey:e}){const{scopeKey:o,to:c,...s}=e[1];if(!c)throw new Error("to is required");return Oe(n,{to:c,...s})},queryKey:Xo(t)}}function Xo(n){return["prepareTransactionRequest",w(n)]}function Zo(n,t={}){return{async queryFn({queryKey:e}){const o=t.abi;if(!o)throw new Error("abi is required");const{functionName:c,scopeKey:s,...r}=e[1],a=(()=>{const i=e[1];if(i.address)return{address:i.address};if(i.code)return{code:i.code};throw new Error("address or code is required")})();if(!c)throw new Error("functionName is required");return jt(n,{abi:o,functionName:c,args:r.args,...a,...r})},queryKey:nc(t)}}function nc(n={}){const{abi:t,...e}=n;return["readContract",w(e)]}function tc(n,t={}){return{async queryFn({queryKey:e}){const o=[],c=e[1].contracts.length;for(let a=0;a<c;a++){const i=e[1].contracts[a],u=(t.contracts?.[a]).abi;o.push({...i,abi:u})}const{scopeKey:s,...r}=e[1];return J(n,{...r,contracts:o})},queryKey:ec(t)}}function ec(n={}){const t=[];for(const e of n.contracts??[]){const{abi:o,...c}=e;t.push({...c,chainId:c.chainId??n.chainId})}return["readContracts",w({...n,contracts:t})]}function oc(n){return{mutationFn(t){return mt(n,t)},mutationKey:["reconnect"]}}function cc(n){return{mutationFn(t){return Qe(n,t)},mutationKey:["sendCalls"]}}function sc(n){return{mutationFn(t){return Be(n,t)},mutationKey:["sendCallsSync"]}}function rc(n){return{mutationFn(t){return Me(n,t)},mutationKey:["sendTransaction"]}}function ac(n){return{mutationFn(t){return xe(n,t)},mutationKey:["sendTransactionSync"]}}function ic(n){return{mutationFn(t){return $e(n,t)},mutationKey:["showCallsStatus"]}}function uc(n){return{mutationFn(t){return De(n,t)},mutationKey:["signTypedData"]}}function dc(n,t={}){return{async queryFn({queryKey:e}){const{abi:o,connector:c}=t;if(!o)throw new Error("abi is required");const{scopeKey:s,...r}=e[1],{address:a,functionName:i}=r;if(!a)throw new Error("address is required");if(!i)throw new Error("functionName is required");return Ge(n,{abi:o,connector:c,...r})},queryKey:lc(t)}}function lc(n={}){const{abi:t,connector:e,...o}=n;return["simulateContract",w(o)]}function yc(n){return{mutationFn(t){return ze(n,t)},mutationKey:["switchAccount"]}}function fc(n,t={}){return{async queryFn({queryKey:e}){const{address:o,message:c,signature:s}=e[1];if(!o||!c||!s)throw new Error("address, message, and signature are required");const{scopeKey:r,...a}=e[1];return await We(n,a)??null},queryKey:hc(t)}}function hc(n){return["verifyMessage",w(n)]}function gc(n,t={}){return{async queryFn({queryKey:e}){const{address:o,message:c,primaryType:s,signature:r,types:a,scopeKey:i,...u}=e[1];if(!o)throw new Error("address is required");if(!c)throw new Error("message is required");if(!s)throw new Error("primaryType is required");if(!r)throw new Error("signature is required");if(!a)throw new Error("types is required");return await He(n,{...u,address:o,message:c,primaryType:s,signature:r,types:a})??null},queryKey:wc(t)}}function wc(n){return["verifyTypedData",w(n)]}function pc(n,t){return{async queryFn({queryKey:e}){const{scopeKey:o,id:c,...s}=e[1];if(!c)throw new Error("id is required");return await Le(n,{...s,id:c})},queryKey:Cc(t),retry(e,o){return o instanceof W?!1:e<3}}}function Cc(n){return["callsStatus",w(n)]}function bc(n){return{mutationFn(t){return je(n,t)},mutationKey:["watchAsset"]}}function mc(n={}){const{enabled:t=!0,onBlock:e,config:o,...c}=n,s=y(n),r=g({config:s}),a=n.chainId??r;O.useEffect(()=>{if(t&&e)return Je(s,{...c,chainId:a,onBlock:e})},[a,s,t,e,c.blockTag,c.emitMissed,c.emitOnBegin,c.includeTransactions,c.onError,c.poll,c.pollingInterval,c.syncConnectedChain])}function Bc(n={}){const{query:t={},watch:e}=n,o=y(n),c=Y(),s=g({config:o}),r=n.chainId??s,a=io(o,{...n,chainId:r}),i=!!(t.enabled??!0);return mc({config:n.config,chainId:n.chainId,...typeof e=="object"?e:{},enabled:!!(i&&(typeof e=="object"?e.enabled:e)),onBlock(u){c.setQueryData(a.queryKey,u)}}),p({...t,...a,enabled:i})}function Ic(n={}){const{enabled:t=!0,onBlockNumber:e,config:o,...c}=n,s=y(n),r=g({config:s}),a=n.chainId??r;O.useEffect(()=>{if(t&&e)return Ue(s,{...c,chainId:a,onBlockNumber:e})},[a,s,t,e,c.onError,c.emitMissed,c.emitOnBegin,c.poll,c.pollingInterval,c.syncConnectedChain])}function Mc(n={}){const{query:t={},watch:e}=n,o=y(n),c=Y(),s=g({config:o}),r=n.chainId??s,a=lo(o,{...n,chainId:r});return Ic({config:n.config,chainId:n.chainId,...typeof e=="object"?e:{},enabled:!!((t.enabled??!0)&&(typeof e=="object"?e.enabled:e)),onBlockNumber(i){c.setQueryData(a.queryKey,i)}}),p({...t,...a})}function xc(n={}){const{query:t={}}=n,e=y(n),o=g({config:e}),c=n.chainId??o,s=fo(e,{...n,chainId:c});return p({...t,...s})}function $c(n={}){const{address:t,query:e={}}=n,o=y(n),c=g({config:o}),s=go(o,{...n,chainId:n.chainId??c}),r=!!(t&&(e.enabled??!0));return p({...e,...s,enabled:r})}function Dc(n={}){const{query:t={}}=n,e=y(n),o=g({config:e}),c=Ze(e,{...n,chainId:n.chainId??o});return p({...t,...c})}function Gc(n){const{query:t={}}=n,e=y(n),o=po(e,n);return p({...t,...o})}function zc(n={}){const{account:t,query:e={}}=n,{address:o}=dn(),c=y(n),s=bo(c,{...n,account:t??o});return p({...e,...s})}function Wc(n={}){const t=y(n);return It.useSyncExternalStoreWithSelector(e=>Ve(t,{onChange:e}),()=>rn(t,n),()=>rn(t,n),e=>e,(e,o)=>e?.uid===o?.uid)}function xn(n={}){const{query:t={},...e}=n,o=y(e),c=Y(),{address:s,connector:r,status:a}=dn({config:o}),i=g({config:o}),u=n.connector??r,{queryKey:d,...l}=Io(o,{...n,chainId:n.chainId??i,connector:u}),I=!!((a==="connected"||a==="reconnecting"&&u?.getProvider)&&(t.enabled??!0)),f=O.useRef(s);return O.useEffect(()=>{const C=f.current;!s&&C?(c.removeQueries({queryKey:d}),f.current=void 0):s!==C&&(c.invalidateQueries({queryKey:d}),f.current=s)},[s,c]),p({...t,...l,queryKey:d,enabled:I,staleTime:Number.POSITIVE_INFINITY})}function Hc(n={}){const{mutation:t}=n,e=y(n),o=to(e),{mutate:c,mutateAsync:s,...r}=Q({...t,...o});return{...r,deployContract:c,deployContractAsync:s}}function Lc(n={}){const{name:t,query:e={}}=n,o=y(n),c=g({config:o}),s=To(o,{...n,chainId:n.chainId??c}),r=!!(t&&(e.enabled??!0));return p({...e,...s,enabled:r})}function jc(n={}){const{name:t,query:e={}}=n,o=y(n),c=g({config:o}),s=So(o,{...n,chainId:n.chainId??c}),r=!!(t&&(e.enabled??!0));return p({...e,...s,enabled:r})}function Uc(n={}){const{key:t,name:e,query:o={}}=n,c=y(n),s=g({config:c}),r=_o(c,{...n,chainId:n.chainId??s}),a=!!(t&&e&&(o.enabled??!0));return p({...o,...r,enabled:a})}function Jc(n={}){const{query:t={}}=n,e=y(n),o=g({config:e}),c=eo(e,{...n,chainId:n.chainId??o});return p({...t,...c})}function Vc(n={}){const{connector:t,query:e={}}=n,o=y(n),{data:c}=xn({config:o,connector:t,query:{enabled:n.account===void 0}}),s=n.account??c?.account,r=g({config:o}),a=co(o,{...n,account:s,chainId:n.chainId??r,connector:t}),i=!!((s||t)&&(e.enabled??!0));return p({...e,...a,enabled:i})}function Yc(n={}){const{query:t={}}=n,e=y(n),o=g({config:e}),c=ro(e,{...n,chainId:n.chainId??o});return p({...t,...c})}function Xc(n={}){const{blockCount:t,rewardPercentiles:e,query:o={}}=n,c=y(n),s=g({config:c}),r=Ao(c,{...n,chainId:n.chainId??s}),a=!!(t&&e&&(o.enabled??!0));return p({...o,...r,enabled:a})}function Zc(n={}){const{query:t={}}=n,e=y(n),o=g({config:e}),c=n.chainId??o,s=Po(e,{...n,chainId:c});return p({...t,...s})}function ns(n){const{contracts:t=[],query:e}=n,o=y(n),c=g({config:o}),s=Jo(o,{...n,chainId:c,contracts:t,query:e});return qt({...e,...s,initialPageParam:s.initialPageParam,structuralSharing:e.structuralSharing??ln})}function ts(n={}){const{to:t,query:e={}}=n,o=y(n),c=g({config:o}),s=Yo(o,{...n,chainId:n.chainId??c}),r=!!(t&&(e.enabled??!0));return p({...e,...s,enabled:r})}function es(n={}){const{address:t,storageKeys:e,query:o={}}=n,c=y(n),s=g({config:c}),r=Ro(c,{...n,chainId:n.chainId??s}),a=!!(t&&e&&(o.enabled??!0));return p({...o,...r,enabled:a})}function os(n={}){const{abi:t,address:e,functionName:o,query:c={}}=n,s=n.code,r=y(n),a=g({config:r}),i=Zo(r,{...n,chainId:n.chainId??a}),u=!!((e||s)&&t&&o&&(c.enabled??!0));return p({...c,...i,enabled:u,structuralSharing:c.structuralSharing??ln})}function cs(n={}){const{contracts:t=[],query:e={}}=n,o=y(n),c=g({config:o}),s=O.useMemo(()=>{if(t.length===0)return;const i=t[0].chainId;if(t.every(u=>u.chainId===i))return i},[t]),r=tc(o,{...n,chainId:s??c}),a=O.useMemo(()=>{let i=!1;for(const u of t){const{abi:d,address:l,functionName:I}=u;if(!d||!l||!I){i=!1;break}i=!0}return!!(i&&(e.enabled??!0))},[t,e.enabled]);return p({...r,...e,enabled:a,structuralSharing:e.structuralSharing??ln})}function ss(n={}){const{mutation:t}=n,e=y(n),o=oc(e),{mutate:c,mutateAsync:s,...r}=Q({...t,...o});return{...r,connectors:e.connectors,reconnect:c,reconnectAsync:s}}function rs(n={}){const{mutation:t}=n,e=y(n),o=cc(e),{mutate:c,mutateAsync:s,...r}=Q({...t,...o});return{...r,sendCalls:c,sendCallsAsync:s}}function as(n={}){const{mutation:t}=n,e=y(n),o=sc(e),{mutate:c,mutateAsync:s,...r}=Q({...t,...o});return{...r,sendCallsSync:c,sendCallsSyncAsync:s}}function is(n={}){const{mutation:t}=n,e=y(n),o=rc(e),{mutate:c,mutateAsync:s,...r}=Q({...t,...o});return{...r,sendTransaction:c,sendTransactionAsync:s}}function us(n={}){const{mutation:t}=n,e=y(n),o=ac(e),{mutate:c,mutateAsync:s,...r}=Q({...t,...o});return{...r,sendTransactionSync:c,sendTransactionSyncAsync:s}}function ds(n={}){const{mutation:t}=n,e=y(n),o=ic(e),{mutate:c,mutateAsync:s,...r}=Q({...t,...o});return{...r,showCallsStatus:c,showCallsStatusAsync:s}}function ls(n={}){const{mutation:t}=n,e=y(n),o=uc(e),{mutate:c,mutateAsync:s,...r}=Q({...t,...o});return{...r,signTypedData:c,signTypedDataAsync:s}}function ys(n={}){const{abi:t,address:e,connector:o,functionName:c,query:s={}}=n,r=y(n),{data:a}=xn({config:r,connector:o,query:{enabled:n.account===void 0}}),i=g({config:r}),u=dc(r,{...n,account:n.account??a?.account,chainId:n.chainId??i}),d=!!(t&&e&&c&&(s.enabled??!0));return p({...s,...u,enabled:d})}function fs(n={}){const{address:t,slot:e,query:o={}}=n,c=y(n),s=g({config:c}),r=Oo(c,{...n,chainId:n.chainId??s}),a=!!(t&&e&&(o.enabled??!0));return p({...o,...r,enabled:a})}function hs(n={}){const{mutation:t}=n,e=y(n),o=yc(e),{mutate:c,mutateAsync:s,...r}=Q({...t,...o});return{...r,connectors:Ut({config:e}).map(a=>a.connector),switchAccount:c,switchAccountAsync:s}}function gs(n={}){const{address:t,query:e={}}=n,o=y(n),c=g({config:o}),s=Bo(o,{...n,chainId:n.chainId??c}),r=!!(t&&(e.enabled??!0));return p({...e,...s,enabled:r})}function ws(n={}){const{blockHash:t,blockNumber:e,blockTag:o,hash:c,query:s={}}=n,r=y(n),a=g({config:r}),i=xo(r,{...n,chainId:n.chainId??a}),u=!!(!(t&&e&&o&&c)&&(s.enabled??!0));return p({...s,...i,enabled:u})}function ps(n={}){const{hash:t,transactionReceipt:e,query:o={}}=n,c=y(n),s=g({config:c}),r=Do(c,{...n,chainId:n.chainId??s}),a=!!(!(t&&e)&&(t||e)&&(o.enabled??!0));return p({...o,...r,enabled:a})}function Cs(n={}){const{address:t,query:e={}}=n,o=y(n),c=g({config:o}),s=zo(o,{...n,chainId:n.chainId??c}),r=!!(t&&(e.enabled??!0));return p({...e,...s,enabled:r})}function bs(n={}){const{hash:t,query:e={}}=n,o=y(n),c=g({config:o}),s=Ho(o,{...n,chainId:n.chainId??c}),r=!!(t&&(e.enabled??!0));return p({...e,...s,enabled:r})}function ms(n={}){const{address:t,message:e,signature:o,query:c={}}=n,s=y(n),r=g({config:s}),a=fc(s,{...n,chainId:n.chainId??r}),i=!!(t&&e&&o&&(c.enabled??!0));return p({...c,...a,enabled:i})}function Is(n={}){const{address:t,message:e,primaryType:o,signature:c,types:s,query:r={}}=n,a=y(n),i=g({config:a}),u=gc(a,{...n,chainId:n.chainId??i}),d=!!(t&&e&&o&&c&&s&&(r.enabled??!0));return p({...r,...u,enabled:d})}function qs(n){const{id:t,query:e={}}=n,o=y(n),c=pc(o,n),s=!!(t&&(e.enabled??!0));return p({...e,...c,enabled:s})}function Ts(n={}){const{query:t={},...e}=n,o=y(e),c=Y(),{address:s,connector:r,status:a}=dn({config:o}),i=g({config:o}),u=n.connector??r,{queryKey:d,...l}=jo(o,{...n,chainId:n.chainId??i,connector:n.connector??r}),I=!!((a==="connected"||a==="reconnecting"&&u?.getProvider)&&(t.enabled??!0)),f=O.useRef(s);return O.useEffect(()=>{const C=f.current;!s&&C?(c.removeQueries({queryKey:d}),f.current=void 0):s!==C&&(c.invalidateQueries({queryKey:d}),f.current=s)},[s,c]),p({...t,...l,queryKey:d,enabled:I,staleTime:Number.POSITIVE_INFINITY})}function Es(n={}){const{mutation:t}=n,e=y(n),o=bc(e),{mutate:c,mutateAsync:s,...r}=Q({...t,...o});return{...r,watchAsset:c,watchAssetAsync:s}}function Ss(n={}){const{enabled:t=!0,onLogs:e,config:o,...c}=n,s=y(n),r=g({config:s}),a=n.chainId??r;O.useEffect(()=>{if(t&&e)return Ye(s,{...c,chainId:a,onLogs:e})},[a,s,t,e,c.abi,c.address,c.args,c.batch,c.eventName,c.fromBlock,c.onError,c.poll,c.pollingInterval,c.strict,c.syncConnectedChain])}function ks(n={}){const{enabled:t=!0,onTransactions:e,config:o,...c}=n,s=y(n),r=g({config:s}),a=n.chainId??r;O.useEffect(()=>{if(t&&e)return Xe(s,{...c,chainId:a,onTransactions:e})},[a,s,t,e,c.batch,c.onError,c.poll,c.pollingInterval,c.syncConnectedChain])}export{As as BaseError,ht as ChainNotConfiguredError,Ks as ConnectorAccountNotFoundError,Ps as ConnectorAlreadyConnectedError,Fs as ConnectorChainMismatchError,Rs as ConnectorNotFoundError,Ns as ConnectorUnavailableReconnectingError,Os as Context,Qs as Hydrate,Ws as ProviderNotFoundError,Hs as SwitchChainNotSupportedError,Bs as WagmiConfig,Ms as WagmiContext,xs as WagmiProvider,$s as WagmiProviderNotFoundError,Nc as cookieStorage,Oc as cookieToInitialState,Ls as createConfig,Ht as createConnector,js as createStorage,yt as custom,Ds as deepEqual,Lt as deserialize,Rc as fallback,Us as http,Js as injected,Bn as mock,Vs as noopStorage,Qc as normalizeChainId,Mn as parseCookie,Ys as serialize,Fc as unstable_connector,dn as useAccount,Xs as useAccountEffect,Zs as useBalance,Bc as useBlock,Mc as useBlockNumber,xc as useBlockTransactionCount,$c as useBytecode,Dc as useCall,Gc as useCallsStatus,zc as useCapabilities,g as useChainId,nr as useChains,Wc as useClient,y as useConfig,tr as useConnect,Ut as useConnections,xn as useConnectorClient,er as useConnectors,ns as useContractInfiniteReads,os as useContractRead,cs as useContractReads,dr as useContractWrite,Hc as useDeployContract,or as useDisconnect,Lc as useEnsAddress,cr as useEnsAvatar,sr as useEnsName,jc as useEnsResolver,Uc as useEnsText,Jc as useEstimateFeesPerGas,Vc as useEstimateGas,Yc as useEstimateMaxPriorityFeePerGas,Jc as useFeeData,Xc as useFeeHistory,Zc as useGasPrice,ns as useInfiniteReadContracts,ts as usePrepareTransactionRequest,es as useProof,rr as usePublicClient,os as useReadContract,cs as useReadContracts,ss as useReconnect,rs as useSendCalls,as as useSendCallsSync,is as useSendTransaction,us as useSendTransactionSync,ds as useShowCallsStatus,ar as useSignMessage,ls as useSignTypedData,ys as useSimulateContract,fs as useStorageAt,hs as useSwitchAccount,ir as useSwitchChain,gs as useToken,ws as useTransaction,ps as useTransactionConfirmations,Cs as useTransactionCount,bs as useTransactionReceipt,ms as useVerifyMessage,Is as useVerifyTypedData,qs as useWaitForCallsStatus,lr as useWaitForTransactionReceipt,Ts as useWalletClient,Es as useWatchAsset,Ic as useWatchBlockNumber,mc as useWatchBlocks,Ss as useWatchContractEvent,ks as useWatchPendingTransactions,yr as useWriteContract,Gs as version,Pc as webSocket};
