import{X as A,Y as y,b as E,p as x,Z as F,B as v,_ as L,$ as T,u as O,a0 as N,a1 as R,a2 as j,a3 as S,A as q,j as I,k as B,a4 as P,s as z,a5 as D,a6 as M,a7 as U,a8 as $}from"./useChainId-D7YJGvzg.js";import{i as W}from"./isAddressEqual-CLzLXNo_.js";import{s as H}from"./sendTransaction-vTUveoQV.js";const _="0x5792579257925792579257925792579257925792579257925792579257925792",k=y(0,{size:32});async function Q(s,a){const{account:d=s.account,capabilities:h,chain:f=s.chain,experimental_fallback:m,experimental_fallbackDelay:p=32,forceAtomic:o=!1,id:g,version:b="2.0.0"}=a,e=d?x(d):null,w=a.calls.map(i=>{const t=i,r=t.abi?A({abi:t.abi,functionName:t.functionName,args:t.args}):t.data;return{data:t.dataSuffix&&r?E([r,t.dataSuffix]):r,to:t.to,value:t.value?y(t.value):void 0}});try{const i=await s.request({method:"wallet_sendCalls",params:[{atomicRequired:o,calls:w,capabilities:h,chainId:y(f.id),from:e?.address,id:g,version:b}]},{retryCount:0});return typeof i=="string"?{id:i}:i}catch(i){const t=i;if(m&&(t.name==="MethodNotFoundRpcError"||t.name==="MethodNotSupportedRpcError"||t.name==="UnknownRpcError"||t.details.toLowerCase().includes("does not exist / is not available")||t.details.toLowerCase().includes("missing or invalid. request()")||t.details.toLowerCase().includes("did not match any variant of untagged enum")||t.details.toLowerCase().includes("account upgraded to unsupported contract")||t.details.toLowerCase().includes("eip-7702 not supported")||t.details.toLowerCase().includes("unsupported wc_ method")||t.details.toLowerCase().includes("feature toggled misconfigured")||t.details.toLowerCase().includes("jsonrpcengine: response has no error or result for request"))){if(h&&Object.values(h).some(l=>!l.optional)){const l="non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.";throw new F(new v(l,{details:l}))}if(o&&w.length>1){const n="`forceAtomic` is not supported on fallback to `eth_sendTransaction`.";throw new L(new v(n,{details:n}))}const r=[];for(const n of w){const l=H(s,{account:e,chain:f,data:n.data,to:n.to,value:n.value?T(n.value):void 0});r.push(l),p>0&&await new Promise(C=>setTimeout(C,p))}const c=await Promise.allSettled(r);if(c.every(n=>n.status==="rejected"))throw c[0].reason;const u=c.map(n=>n.status==="fulfilled"?n.value:k);return{id:E([...u,y(f.id,{size:32}),_])}}throw O(i,{...a,account:e,chain:a.chain})}}async function G(s,a){async function d(e){if(e.endsWith(_.slice(2))){const i=j(S(e,-64,-32)),t=S(e,0,-64).slice(2).match(/.{1,64}/g),r=await Promise.all(t.map(u=>k.slice(2)!==u?s.request({method:"eth_getTransactionReceipt",params:[`0x${u}`]},{dedupe:!0}):void 0)),c=r.some(u=>u===null)?100:r.every(u=>u?.status==="0x1")?200:r.every(u=>u?.status==="0x0")?500:600;return{atomic:!1,chainId:N(i),receipts:r.filter(Boolean),status:c,version:"2.0.0"}}return s.request({method:"wallet_getCallsStatus",params:[e]})}const{atomic:h=!1,chainId:f,receipts:m,version:p="2.0.0",...o}=await d(a.id),[g,b]=(()=>{const e=o.status;return e>=100&&e<200?["pending",e]:e>=200&&e<300?["success",e]:e>=300&&e<700?["failure",e]:e==="CONFIRMED"?["success",200]:e==="PENDING"?["pending",100]:[void 0,e]})();return{...o,atomic:h,chainId:f?N(f):void 0,receipts:m?.map(e=>({...e,blockNumber:T(e.blockNumber),gasUsed:T(e.gasUsed),status:R[e.status]}))??[],statusCode:b,status:g,version:p}}async function V(s,a){const{account:d=s.account,chainId:h,nonce:f}=a;if(!d)throw new q({docsPath:"/docs/eip7702/prepareAuthorization"});const m=x(d),p=(()=>{if(a.executor)return a.executor==="self"?a.executor:x(a.executor)})(),o={address:a.contractAddress??a.address,chainId:h,nonce:f};return typeof o.chainId>"u"&&(o.chainId=s.chain?.id??await I(s,B,"getChainId")({})),typeof o.nonce>"u"&&(o.nonce=await I(s,P,"getTransactionCount")({address:m.address,blockTag:"pending"}),(p==="self"||p?.address&&W(p.address,m.address))&&(o.nonce+=1)),o}class X extends v{constructor(a){super(`Call bundle failed with status: ${a.statusCode}`,{name:"BundleFailedError"}),Object.defineProperty(this,"result",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.result=a}}async function ee(s,a){const{id:d,pollingInterval:h=s.pollingInterval,status:f=({statusCode:c})=>c===200||c>=300,retryCount:m=4,retryDelay:p=({count:c})=>~~(1<<c)*200,timeout:o=6e4,throwOnFailure:g=!1}=a,b=z(["waitForCallsStatus",s.uid,d]),{promise:e,resolve:w,reject:i}=D();let t;const r=M(b,{resolve:w,reject:i},c=>{const u=U(async()=>{const n=l=>{clearTimeout(t),u(),l(),r()};try{const l=await $(async()=>{const C=await I(s,G,"getCallsStatus")({id:d});if(g&&C.status==="failure")throw new X(C);return C},{retryCount:m,delay:p});if(!f(l))return;n(()=>c.resolve(l))}catch(l){n(()=>c.reject(l))}},{interval:h,emitOnBegin:!0});return u});return t=o?setTimeout(()=>{r(),clearTimeout(t),i(new Y({id:d}))},o):void 0,await e}class Y extends v{constructor({id:a}){super(`Timed out while waiting for call bundle with id "${a}" to be confirmed.`,{name:"WaitForCallsStatusTimeoutError"})}}export{G as g,V as p,Q as s,ee as w};
