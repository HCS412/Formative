import{C as L,f as b,A as v,h as S,r as _,B,p as G,j as p,k as j,l as O,m as U,L as W,n as k,o as D,q as H,t as f,u as J}from"./useChainId-D7YJGvzg.js";function K({chain:t,currentChainId:a}){if(!t)throw new L;if(a!==t.id)throw new b({chain:t,currentChainId:a})}const w=new W(128);async function V(t,a){const{account:u=t.account,chain:i=t.chain,accessList:l,authorizationList:o,blobs:m,data:y,gas:T,gasPrice:g,maxFeePerBlobGas:E,maxFeePerGas:R,maxPriorityFeePerGas:q,nonce:C,type:N,value:P,...M}=a;if(typeof u>"u")throw new v({docsPath:"/docs/actions/wallet/sendTransaction"});const r=u?G(u):null;try{S(a);const e=await(async()=>{if(a.to)return a.to;if(a.to!==null&&o&&o.length>0)return await _({authorization:o[0]}).catch(()=>{throw new B("`to` is required. Could not infer from `authorizationList`.")})})();if(r?.type==="json-rpc"||r===null){let s;i!==null&&(s=await p(t,j,"getChainId")({}),K({currentChainId:s,chain:i}));const c=t.chain?.formatters?.transactionRequest?.format,F=(c||O)({...U(M,{format:c}),accessList:l,account:r,authorizationList:o,blobs:m,chainId:s,data:y,gas:T,gasPrice:g,maxFeePerBlobGas:E,maxFeePerGas:R,maxPriorityFeePerGas:q,nonce:C,to:e,type:N,value:P},"sendTransaction"),z=w.get(t.uid),x=z?"wallet_sendTransaction":"eth_sendTransaction";try{return await t.request({method:x,params:[F]},{retryCount:0})}catch(I){if(z===!1)throw I;const n=I;if(n.name==="InvalidInputRpcError"||n.name==="InvalidParamsRpcError"||n.name==="MethodNotFoundRpcError"||n.name==="MethodNotSupportedRpcError")return await t.request({method:"wallet_sendTransaction",params:[F]},{retryCount:0}).then(d=>(w.set(t.uid,!0),d)).catch(d=>{const h=d;throw h.name==="MethodNotFoundRpcError"||h.name==="MethodNotSupportedRpcError"?(w.set(t.uid,!1),n):h});throw n}}if(r?.type==="local"){const s=await p(t,k,"prepareTransactionRequest")({account:r,accessList:l,authorizationList:o,blobs:m,chain:i,data:y,gas:T,gasPrice:g,maxFeePerBlobGas:E,maxFeePerGas:R,maxPriorityFeePerGas:q,nonce:C,nonceManager:r.nonceManager,parameters:[...D,"sidecars"],type:N,value:P,...M,to:e}),c=i?.serializers?.transaction,A=await r.signTransaction(s,{serializer:c});return await p(t,H,"sendRawTransaction")({serializedTransaction:A})}throw r?.type==="smart"?new f({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"}):new f({docsPath:"/docs/actions/wallet/sendTransaction",type:r?.type})}catch(e){throw e instanceof f?e:J(e,{...a,account:r,chain:a.chain||void 0})}}export{K as a,V as s};
